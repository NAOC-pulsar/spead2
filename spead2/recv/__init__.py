"""Receive SPEAD protocol

Item format
===========
At present only a subset of the possible SPEAD format strings are accepted.
Also, the SPEAD protocol does not specify how items are to be represented in
Python. The following are accepted.

 - Any descriptor with a numpy header (will be handled by numpy). If the dtype
   contains only a single field which is non-native endian, it will be
   converted to native endian in-place. In other cases, the value retrieved
   from numpy will still be correct, but usage may be slow.
 - If no numpy header is present, the following may be used in the format
   with zero copy and good efficiency:

   - u8, u16, u32, u64
   - i8, i16, i32, i64
   - f32, f64
   - b8
   - c8 (converted to dtype S1)

   This will be converted to a numpy dtype. If there are multiple fields,
   their names will be generated by numpy (`f0`, `f1`, etc). At most one
   element of the shape may indicate a variable-length field, whose length
   will be computed from the size of the item, or 0 if any other element of
   the shape is zero.
 - The `u`, `i`, `c` and `b` types may also be used with other sizes, but it
   will invoke a slow conversion process and is not recommended for large
   arrays. The valid range of the `c` conversion depends on the Python
   version: for Python 2 it must be 0 to 255, for Python 3 it is interpreted
   as a Unicode code point.

Two cases are treated specially:

 - A zero-dimensional array is returned as a scalar, rather than a
   zero-dimensional array object.
 - A one-dimensional array of characters (numpy dtype 'S1') is converted to a
   Python string, using ASCII encoding.

Immediate values are treated as items with heap_address_bits/8
bytes, in the order they appeared in the original packet.
"""

import spead2 as _spead2
import numbers as _numbers
import logging
from spead2._recv import *

_logger = logging.getLogger(__name__)

class ItemGroup(object):
    def __init__(self):
        self._by_id = {}
        self._by_name = {}

    def update(self, heap):
        """Update the item descriptors and items from an incoming heap.

        Parameters
        ----------
        heap : :class:`spead2.recv.Heap`
            Incoming heap

        Returns
        -------
        list
            Items that have been updated from this heap
        """
        for descriptor in heap.get_descriptors():
            item = _spead2.Item.from_raw(descriptor, bug_compat=heap.bug_compat)
            self._by_id[descriptor.id] = item
            self._by_name[descriptor.name] = item
        updated_items = []
        for raw_item in heap.get_items():
            try:
                item = self._by_id[raw_item.id]
            except KeyError:
                _logger.warning('Item with ID %d received but there is no descriptor', raw_item.id)
            else:
                item.set_from_raw(raw_item)
                updated_items.append(item)
        return updated_items

    def __getitem__(self, key):
        if isinstance(key, _numbers.Integral):
            return self._by_id[key]
        else:
            return self._by_name[key]

    def __contains__(self, key):
        if isinstance(key, _numbers.Integral):
            return key in self._by_id
        else:
            return key in self._by_name

    def keys(self):
        return self._by_name.keys()

    def values(self):
        return self._by_name.values()

    def items(self):
        return self._by_name.items()

    def __len__(self):
        return len(self._by_name)
